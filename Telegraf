Not:grup katƒ±ldƒ±ƒüƒ±nda grupta zaten eklenmi≈ü mi kontrol et.



ctx.message>{from:{kimden},chat:{type:grup mu √∂zel g√∂r√º≈üme mi}}
ctx.botInfo>{bot bilgilerini veri.  }
ctx.reply("") mesaj g√∂nderme
ctx.replyWithHTML( "<i>username </i>", ) Sadece bunlar desteklenir:
<b>bold</b>, <strong>bold</strong>
<i>italic</i>, <em>italic</em>
<u>underline</u>, <ins>underline</ins>
<s>strikethrough</s>, <strike>strikethrough</strike>, <del>strikethrough</del>
<b>bold <i>italic bold <s>italic bold strikethrough</s> <u>underline italic bold</u></i> bold</b>
<a href="http://www.example.com/">inline URL</a>
<a href="tg://user?id=123456789">inline mention of a user</a>
<code>inline fixed-width code</code>
<pre>pre-formatted fixed-width code block</pre>
<pre><code class="language-python">pre-formatted fixed-width code block written in the Python programming language</code></pre>

-Herhangi bir dosya g√∂nderirken resim,video,metin..: metin kƒ±smƒ±nda markdown kullanmak i√ßin options kƒ±smƒ±nda parse_mode:"Markdown"
*bold \*text*
_italic \*text_
__underline__
~strikethrough~
*bold _italic bold ~italic bold strikethrough~ __underline italic bold___ bold*
[inline URL](http://www.example.com/)
[inline mention of a user](tg://user?id=123456789)
`inline fixed-width code`
```
pre-formatted fixed-width code block
```
```python
pre-formatted fixed-width code block written in the Python programming language
```  //b√∂ylece bu stiller kullanƒ±labilir. 
bot.on('sticker', (ctx) => ctx.reply('üëç'))   //private kƒ±smƒ±nda √ßal≈üƒ±yor ancak gruplarda √ßalƒ±≈ümƒ±yor.
bot.on('sticker')>ctx.message kƒ±smƒ±nda sticker objesi gelir.


-bir metin g√∂nderirken options kƒ±smƒ±nda aktif keyboardƒ± silmesini saƒülayabiliriz.
  ctx.reply("button deleted",{reply_markup: {remove_keyboard: true}})
dosya g√∂nderimi:
    video:    ctx.replyWithVideo({source:path})       //dosya yolu veya
      ctx.replyWithVideo({
    source: fs.createReadStream('/path/to/video.mp4')
  })

    resim:    ctx.replyWithPhoto('https://picsum.photos/200/300/')  //url ile veya     √º
     ctx.replyWithPhoto({
        url: 'https://picsum.photos/200/300/?random',
        filename: 'kitten.jpg'
      })

    sticker:  ctx.replyWithSticker('123123jkbhj6b')        //file_id ile g√∂nderilir.

    ses:  ctx.replyWithVoice({
    source: Buffer.alloc()
  })

  middleware: await next() sonraki midleeware ge√ßer ve onun bitmesini bekler
  bot.use(async (ctx, next) => {
  console.time(`Processing update ${ctx.update.update_id}`)
  await next() // runs next middleware
  // runs after next middleware finishes
  console.timeEnd(`Processing update ${ctx.update.update_id}`)
})

Mesaj silme:ctx.deleteMessage(mesaj_id) mesaj id yazƒ±lmazsa son mesajƒ± siler.
    const is=await ctx.deleteMessage(357)
    console.log(is)

    private mod:botfather ile deƒüi≈ütirilebilir:Deƒüi≈üikliƒüi tanƒ±mlamak i√ßin botu kaldƒ±rƒ±p tekrar y√ºklemek gerek.
    enabled:sadece komut ve bota √∂zel mesajlarƒ± algƒ±lar.
    disabled : t√ºm mesajlarƒ± algƒ±lar.

    botu sohbetten atmak:
    bot.command('quit', (ctx) => {
  ctx.telegram.leaveChat(ctx.message.chat.id)
  ctx.leaveChat()
      })

      √úye i≈ülemleri:belirtilen parametreler zorunlu deƒüil.Parametre konulmazsa mesajƒ± yazandan yola √ßƒ±kƒ±lƒ±r.  
      ctx.getChat(chat_id) chat d√∂nd√ºr√ºl√ºr.ctx.message.chat ile ortak yanlarƒ± var.
      ctx.getChatAdministrators(chat_id)
      ctx.getChatMember(userId veya chat_id)
      ctx.getChatMemberCount(chat_id)

     ctx vs telegram: ctx kullanƒ±rken belirtilen √ßoƒüu alanƒ±n doldurulmasƒ± zorunlu deƒüilken telegramde zorunludur.(T√ºm alanlar deƒüil.)
     Telegram tanƒ±mlama:
     const { Telegraf ,Telegram}=require("telegraf")
     const telegram=new Telegram(token)
     ctx:her isteƒüin callbacƒüindeki ctx.


     Bot tanƒ±mlama:olu≈üturma: 
     -keyboard ve inline keyboard:
     keyboard:footer kƒ±smƒ±nda g√∂sterir.Deƒüer mesaj olarak yazƒ±lƒ±r.
       Markup.removeKeyboard() ile silinmesi gerekir ancak silinmiyor onun yerine.
         ctx.reply("button deleted",{reply_markup: {remove_keyboard: true}} ile siliniebilir.
     inlineKeyboard:mesajƒ±n altƒ±nda g√∂sterilir.Deƒüer callback ile d√∂ner.Mesaj olarak yazƒ±lmaz.
     const { Markup}=require("telegraf")
      Markup.keyboard([])
    √∂rnek1:
  ctx.reply("bot gelioo",Markup.keyboard([
    ["mehmet","ahmet"], //1.satƒ±r
    ["deli","veli"]//2.satƒ±r
  ]).oneTime().placeholder())   //placeholder inputta g√∂r√ºnecek kƒ±sm.oneTime sadece tek kullanƒ±mlƒ±k der. resize() ve selective() de kullanƒ±lƒ±r.
                                //butona tƒ±kladƒ±ƒüƒ±nda buton deƒüeri text e≈üit olur.ve mesaj olarak gelir.

  √∂rnek2: ctx.reply(
    'Special buttons keyboard',
    Markup.keyboard([
      Markup.button.contactRequest('Send contact'),     //tel no ister
      Markup.button.locationRequest('Send location')      //lokasyon ister
    ]).resize()
  )   //ctx.message.contact ile tel no alƒ±nƒ±r. 
      //ctx.message.location ile locasyon alƒ±nƒ±r.

      bot.on("location") ve bot.on("contact") ile bilgiler alƒ±nabilir.

      √∂rnek3:
          Markup.keyboard(['one', 'two', 'three', 'four', 'five', 'six'], {
      wrap: (btn, index, currentRow) => currentRow.length >= (index + 1 ) / 2
    })   //indexleme d√∂nd√ºr√ºlen deƒüere g√∂re yapƒ±lƒ±r.
    
    √∂rnek4:bot.action('Dr Pepper', (ctx, next) => {
  return ctx.reply('üëç').then(() => next())
})  //botun d√∂nd√ºrd√ºƒü√º deƒüer Dr Pepper ise √ßalƒ±≈ütƒ±rƒ±r ardƒ±ndan devam ettirir.

Inline keyboard:metin kƒ±smƒ±nda metnin altƒ±na konur.
    Markup.inlineKeyboard([
      Markup.button.callback('Coke', 'Coke'),
      Markup.button.callback('Dr Pepper', 'Dr Pepper', Math.random() > 0.1),
    ])

      Markup.button.callback(label, val, true gizler.false g√∂sterir),
-Inline keyboardta gelen bilgile
bot.action("data") ile yakalanƒ±r.
-ctx.answerCbQuery("text",options) ile cevap verilebilir.true d√∂ner i≈ülem tamamlanƒ±rsa.text kƒ±smƒ±nƒ± doldurmak zorunlu deƒüildir.options={ show_alert:true}
    √∂rnek1:ctx.reply(
    'random example',
    Markup.inlineKeyboard([
      Markup.button.callback('Coke', 'Coke'),
      Markup.button.callback('Dr Pepper', 'Dr Pepper', Math.random() > 0.1),
      Markup.button.callback('Pepsi', 'Pepsi',true)
    ])
    √∂rnek2:  return ctx.replyWithPhoto({ url: 'https://picsum.photos/200/300/?random' },
    {
      caption: 'Caption',
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        Markup.button.callback('Plain', 'plain'),
        Markup.button.callback('Italic', 'italic')
      ])
    }
  ) //options kƒ±smƒ±nda eklendiƒüinde ... ile eklenir.

  bot.action('italic', async (ctx) => {
  await ctx.answerCbQuery()
  await ctx.editMessageCaption('_Caption_', {
    parse_mode: 'Markdown',
    ...Markup.inlineKeyboard([
      Markup.button.callback('Plain', 'plain'),
      Markup.button.callback('* Italic *', 'italic')
    ])
  })
}) //resimle kullanƒ±mƒ±


Telegraf api:
const bot=new Telegraf(token)
bot.hears("asd") asd mesajƒ± yazƒ±ldƒ±ƒüƒ±nda 
bot.command("log") /log komutu yazƒ±lƒ±nca
bot.on("photo,audio,contact,location,groupchat_created..") gibi pek √ßok tetikleme ile √ßalƒ±≈üan middleware saƒülar.
bot.action("") callback query i√ßin √ßalƒ±≈üacak middleware.Markup.button.callback('Plain', 'plain'), i√ßin.



Hata ayƒ±klama:Default olarak telegram tekrar dener ve ardƒ±ndan consola yazar.App √ß√∂ker.
Bunu engellemek i√ßin: bot.catch(err=>)
err.response=hata bilgilerini
err.on=hatanƒ±n olduƒüu b√∂lge

 Soru-cevap questionlarƒ± olu≈üturma:npm install grammy @grammyjs/stateless-question ile yapƒ±lƒ±r.√ñzel soru-cevap ili≈ükisi saƒülar.

 √áoklu soru cevap i√ßim.Form ≈üeklinde tek tek a≈üamalƒ± ≈üekilde sahneler i√ßin.Scenes kullanƒ±lƒ±r.session gereklidir.
 link:https://github.com/telegraf/telegraf/issues/705 
 const {Scenes,session}=require("telegraf")
 const contactDataWizard = new Scenes.WizardScene(
  'CONTACT_DATA_WIZARD_SCENE_ID', // first argument is Scene_ID, same as for BaseScene //√∂zel ad
  (ctx) => {
    ctx.reply('What is your name?');
    ctx.wizard.state.contactData = {};
    return ctx.wizard.next();
  },
  (ctx) => {
    // validation example
    if (ctx.message.text.length < 2) {
      ctx.reply('Please enter name for real');
      return; 
    }
    ctx.wizard.state.contactData.fio = ctx.message.text;
    ctx.reply('Enter your e-mail');
    return ctx.wizard.back()
    return ctx.wizard.next();
  },
  async (ctx) => {
    ctx.wizard.state.contactData.email = ctx.message.text;
    ctx.reply("Thank you for your replies, we'll contact your soon");
    console.log(ctx.wizard.state.contactData)
    // await mySendContactDataMomentBeforeErase(ctx.wizard.state.contactData);
    return ctx.scene.leave();
  },
  );

  const stage = new Scenes.Stage([contactDataWizard]);
  bot.use(session()); 
  bot.use(stage.middleware());
   bot.hears('s',(ctx) => ctx.scene.enter('CONTACT_DATA_WIZARD_SCENE_ID')); 

-a≈üamala kƒ±sƒ±mlarƒ±nda ge√ßi≈üler yapmak:
  ctx.wizard.next() - to advance to next step;
ctx.wizard.back() - to go back to previous step;
ctx.wizard.cursor - to get current step index;
ctx.wizard.selectStep(index) - to jump straight to a given step index, can be used to implement branching;
